"""
[S/W 문제해결 기본] 10일차 - Contact
문제 내용
각 원은 개개인을 의미하며, 원 안의 숫자는 그사람의 번호를 나타내고 빨간원은 연락을 시작하는 당번을 의미한다.
화살표는 연락이 가능한 방향을 의미한다.
위의 예시에서는 7번과 1번은 서로 연락이 가능하다,
하지만 2번과 7번의 경우 2번은 7번에게 연락할 수 있지만 7번은 2번에게 연락할 수 없다.
비상연락망이 가동되면 아래 그림과 같이 연락을 시작하는 당번인 2번은 연락 가능한 7번과 15번에 동시에 연락을 취한다 (다자 간 통화를 사용한다고 가정).
그 다음 아래와 같이 7번은 1번에게, 15번은 4번에게 연락을 취한다 (이 과정은 동시에 일어난다고 가정한다).
위의 모습이 연락이 끝난 마지막 모습이 되며, 마지막에 동시에 연락 받은 사람은 8번, 10번, 17번의 세 명이다.
이 중에서 가장 숫자가 큰 사람은 17번이므로 17을 반환하면 된다.
※ 3, 6, 11, 22번은 시간이 지나도 연락을 받지 못한다.

[입력]
입력의 첫 번째 줄에는 입력 받는 데이터의 길이와 시작점이 주어진다.
그 다음 줄에 입력받는 데이터는 {from, to, from, to, …} 의 순서로 해석되며 예시의 경우는 {2, 7, 11, 6, 6, 2, 2, 15, 15, 4, 4, 2, 4, 10, 7, 1, 1, 7, 1, 8, 1, 17, 3, 22}와 같다.
그런데 순서에는 상관이 없으므로 다음과 같이 주어진 인풋도 동일한 비상연락망을 나타낸다 (같은 비상연락망을 표현하는 다양한 인풋이 존재 가능하다).
{1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 4, 2}
다음과 같이 동일한 {from, to}쌍이 여러 번 반복되는 경우도 있으며, 한 번 기록된 경우와 여러 번 기록된 경우의 차이는 없다.
{1, 17, 1, 17, 1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 11, 6, 4, 2}

[출력]
#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.

최초 작성 2019.02.25 PBY
최종 제출 2019.02.26
"""

# 제출 시 삭제할 부분
import sys
sys.stdin = open("C:/Users/student/Documents/week2/day1/Algorithms/190226_05_input.txt", "r")

for tc in range(10):

    # input
    length, start = list(map(int, input().split()))
    fromto = list(map(int, input().split()))
    array = [[0 for j in range(100)] for i in range(100)]
    for i in range(1, length, 2):
        array[fromto[i-1]-1][fromto[i]-1] = 1

    # 양방향 연락이 가능하기 때문에 visited가 필요하다. (이것을 append로 구현하면 훨씬 속도가 빨라진다)
    visited = [0] * 100

    # BFS 구현을 위한 큐를 두 개 사용하였다. (이전 레벨에 연락이 간 것, 다음 레벨에 연락을 돌릴 곳)
    Q1 = [0] * 100
    front1 = 0; rear1 = 0
    Q2 = [0] * 100
    front2 = 0; rear2 = -1

    # start 지점을 먼저 큐에 넣고 시작한다.
    Q1[rear1] = start

    # 최대한 연락이 닿을 때까지 while문을 돌린다. (다음 자식 노드가 아예 없을 때까지)
    while True:

        # 자식이 존재하는지 확인하기 위해 초기화를 매번 해줬다.
        check = 0

        # Q1에 존재하는 부모 노드의 개수를 알기 위해 따로 변수를 사용했다.
        nodenum = 0

        # Q1을 탐색하면서
        for node in Q1[front1:rear1+1]:
            nodenum += 1 # 부모 노드의 개수 확인하고

            # 연락망을 확인하면서
            for j in range(len(array)):

                # 아직 연락이 안 갔으면 연락을 돌린다.
                if array[node-1][j] == 1 and not visited[j]:
                    rear2 += 1
                    Q2[rear2] = j+1
                    visited[j] = 1

                    # 자식이 존재함을 체크
                    check = 1

        # 더 이상 연락을 돌릴 수 없다면 (자식노드가 없다면)
        if check == 0:

            # max값 찾는 연산
            maxvalue = Q1[front1]
            for findmax in Q1[front1:rear1+1]:
                if findmax > maxvalue:
                    maxvalue = findmax

            # 정답을 출력 후 while문 종료
            print("#{} {}".format(tc+1, maxvalue))
            break

        # Q1에서 탐색이 끝난 부모 노드의 개수를 모두 빼낸다.
        front1 += nodenum

        # 탐색이 종료되었으니 Q2에 있는 것이 다시 Q1으로 업데이트 된다.
        for node in Q2[front2:rear2+1]:
            front2 += 1 # Q2에서 꺼내면서
            rear1 += 1 # Q1에 추가
            Q1[rear1] = node

